name: Update live data (prices, RSI, SST)

on:
  schedule:
    # Weekdays, every 5 min during 06:00â€“13:59 PT
    - cron: "*/5 13-21 * * 1-5"
  workflow_dispatch:

jobs:
  run:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      # Edit this list if needed
      TICKERS: "SCHD,VTI,VXUS,XLV,VNQ,BND,GEMI"
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install yfinance pandas numpy

      - name: Write updater script
        shell: bash
        run: |
          mkdir -p scripts
          cat > scripts/update_live.py << 'PY'
import json, os, time
from datetime import datetime, timezone
import numpy as np
import pandas as pd
import yfinance as yf

LIVE_PATH = "data_live.json"  # must exist or will be created

# ---------- Helpers ----------
def rsi_wilder(series, period=14):
    delta = series.diff()
    gain = delta.clip(lower=0)
    loss = -delta.clip(upper=0)
    avg_gain = gain.ewm(alpha=1/period, adjust=False).mean()
    avg_loss = loss.ewm(alpha=1/period, adjust=False).mean()
    rs = avg_gain / (avg_loss.replace(0, np.nan))
    rsi = 100 - (100 / (1 + rs))
    return float(round(rsi.iloc[-1], 2))

def safe_load_json(path):
    try:
        with open(path, "r") as f:
            return json.load(f)
    except Exception:
        return {}

def safe_write_json(path, obj):
    with open(path, "w") as f:
        json.dump(obj, f, indent=2, ensure_ascii=False)

def fetch_last_price(ticker):
    t = yf.Ticker(ticker)
    # intraday attempt
    try:
        df = t.history(period="1d", interval="1m")
        if df is not None and not df.empty:
            return float(round(df["Close"].iloc[-1], 2))
    except Exception:
        pass
    # daily fallback
    try:
        df = t.history(period="5d", interval="1d")
        if df is not None and not df.empty:
            return float(round(df["Close"].iloc[-1], 2))
    except Exception:
        pass
    return None

def fetch_rsi14(ticker):
    t = yf.Ticker(ticker)
    df = t.history(period="6mo", interval="1d")
    if df is None or df.empty or len(df) < 20:
        return None
    return rsi_wilder(df["Close"], period=14)

# ---------- Short Squeeze inputs (free, user-supplied) ----------
# Fill this with the tickers you want ranked (shares short, float, 30d avg vol, entry/stop/targets).
SST_INPUTS = {
    # "PLUG": {"si_shares": 100_000_000, "float_shares": 600_000_000, "avg_vol_30d": 25_000_000,
    #          "entry": 3.10, "stop": 2.72, "t1": 3.45, "t2": 3.90}
}

def build_sst(prices, rsi_map):
    out = {}
    for tk, vals in SST_INPUTS.items():
        si_sh = vals.get("si_shares")
        flt = vals.get("float_shares")
        avgv = vals.get("avg_vol_30d")
        entry = vals.get("entry")
        stop = vals.get("stop")
        t1 = vals.get("t1")
        t2 = vals.get("t2")

        rsi_val = rsi_map.get(tk)
        last = prices.get(tk)

        def safe_pct(x, y):
            try:
                return round(100 * x / y, 2) if x is not None and y else None
            except Exception:
                return None

        def safe_div(x, y):
            try:
                return round(x / y, 2) if x is not None and y else None
            except Exception:
                return None

        si_pct_float = safe_pct(si_sh, flt)
        dtc = safe_div(si_sh, avgv)

        out[tk] = {
            "rsi": rsi_val if rsi_val is not None else "data not available",
            "si_percent_float": si_pct_float if si_pct_float is not None else "data not available",
            "days_to_cover": dtc if dtc is not None else "data not available",
            "entry": entry if entry is not None else "data not available",
            "stop": stop if stop is not None else "data not available",
            "t1": t1 if t1 is not None else "data not available",
            "t2": t2 if t2 is not None else "data not available",
            "last": last if last is not None else "data not available",
            "sources": ["User-supplied SI/float/avgvol (free method). Edit in scripts/update_live.py"]
        }
    return out

# ---------- Ranking ----------
def _to_num(x):
    try:
        return float(x)
    except Exception:
        return None

def squeeze_score(item):
    # Higher is better: high SI%, high DTC, low RSI
    rsi = _to_num(item.get("rsi"))
    si_pct = _to_num(item.get("si_percent_float"))
    dtc = _to_num(item.get("days_to_cover"))
    if si_pct is None and dtc is None and rsi is None:
        return 0.0
    si_norm  = min(max((si_pct or 0.0), 0.0), 40.0) / 40.0   # cap 40%
    dtc_norm = min(max((dtc or 0.0), 0.0), 10.0) / 10.0      # cap 10 days
    rsi_norm = 0.0 if rsi is None else max(0.0, 70.0 - rsi) / 70.0  # oversold better
    score = 0.5*si_norm + 0.3*dtc_norm + 0.2*rsi_norm
    return round(score*100, 1)

def top5_from_sst(sst_dict):
    rows = []
    for tk, v in sst_dict.items():
        sc = squeeze_score(v)
        rows.append({
            "ticker": tk,
            "score": sc,
            "rsi": v.get("rsi"),
            "si_percent_float": v.get("si_percent_float"),
            "days_to_cover": v.get("days_to_cover"),
            "entry": v.get("entry"),
            "stop": v.get("stop"),
            "targets": [v.get("t1"), v.get("t2")],
            "sources": v.get("sources", [])
        })
    rows.sort(key=lambda x: x["score"], reverse=True)
    return rows[:5]

# ---------- Main ----------
def main():
    tickers = os.getenv("TICKERS", "SCHD,VTI,VXUS,XLV,VNQ,BND,GEMI").split(",")
    tickers = [t.strip().upper() for t in tickers if t.strip()]

    # Ensure base JSON exists
    if not os.path.exists(LIVE_PATH):
        base = {"Prices": {}, "RSI": {}, "SST": {}, "SST_TOP5": [], "last_update_utc": ""}
        safe_write_json(LIVE_PATH, base)

    data = safe_load_json(LIVE_PATH)

    # Prices
    prices = {}
    for tk in tickers:
        prices[tk] = fetch_last_price(tk)
        time.sleep(0.2)

    # RSI
    rsi_map = {}
    for tk in tickers:
        rsi_map[tk] = fetch_rsi14(tk)

    # Merge
    data.setdefault("Prices", {})
    for tk in tickers:
        if prices[tk] is not None:
            data["Prices"][tk] = prices[tk]
    data["RSI"] = {tk: (rsi_map[tk] if rsi_map[tk] is not None else "data not available") for tk in tickers}

    # SST + Top5
    sst = build_sst(prices, data["RSI"])
    data["SST"] = sst
    data["SST_TOP5"] = top5_from_sst(sst)

    # Timestamp
    data["last_update_utc"] = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")

    safe_write_json(LIVE_PATH, data)

if __name__ == "__main__":
    main()
PY

      - name: Ensure base JSON exists
        shell: bash
        run: |
          if [ ! -f data_live.json ]; then
            cat > data_live.json << 'JSON'
{
  "Prices": {},
  "RSI": {},
  "SST": {},
  "SST_TOP5": [],
  "last_update_utc": ""
}
JSON
          fi

      - name: Run updater
        run: python scripts/update_live.py

      - name: Commit changes
        shell: bash
        run: |
