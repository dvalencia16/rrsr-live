name: Update live data (holdings prices + RSI + SST + Market)

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - "scripts/**"
      - "sst_inputs.json"
      - "data_live.json"
      - ".github/workflows/update_live.yml"
  schedule:
    - cron: "*/5 13-21 * * 1-5"

jobs:
  run:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      TICKERS: "SCHD,VTI,VXUS,XLV,VNQ,BND,GEMI"   # holdings universe
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip setuptools wheel
          pip install --no-cache-dir yfinance==0.2.43 pandas==2.2.2 numpy==1.26.4

      - name: Write updater script
        shell: bash
        run: |
          mkdir -p scripts
          cat > scripts/update_live.py <<'PY'
          import json, os, time
          from datetime import datetime, timezone
          import numpy as np
          import pandas as pd
          import yfinance as yf

          LIVE_PATH = "data_live.json"
          SST_PATH  = "sst_inputs.json"

          def safe_load_json(path, default):
              try:
                  with open(path, "r") as f:
                      return json.load(f)
              except Exception:
                  return default

          def safe_write_json(path, obj):
              with open(path, "w") as f:
                  json.dump(obj, f, indent=2, ensure_ascii=False)

          def rsi_wilder(series, period=14):
              delta = series.diff()
              gain = delta.clip(lower=0)
              loss = -delta.clip(upper=0)
              avg_gain = gain.ewm(alpha=1/period, adjust=False).mean()
              avg_loss = loss.ewm(alpha=1/period, adjust=False).mean()
              rs = avg_gain / (avg_loss.replace(0, 1e-12))
              rsi = 100 - (100 / (1 + rs))
              return float(round(rsi.iloc[-1], 2))

          def fetch_prices_and_rsi(tickers):
              """Batch download to avoid per-ticker failures. Retry with daily if 1m empty."""
              prices = {t: None for t in tickers}
              rsi    = {t: "data not available" for t in tickers}

              # 1) try intraday last
              try:
                  df1 = yf.download(tickers=tickers, period="1d", interval="1m",
                                    progress=False, auto_adjust=False, group_by="ticker")
              except Exception:
                  df1 = None

              for t in tickers:
                  try:
                      if isinstance(df1, pd.DataFrame) and not df1.empty:
                          sub = df1 if "Close" in df1.columns else df1.get(t)
                          if sub is not None and not sub.empty:
                              c = sub["Close"] if "Close" in sub else sub["Close"]
                              if c is not None and not c.empty:
                                  prices[t] = float(round(c.dropna().iloc[-1], 2))
                  except Exception:
                      pass

              # 2) fill missing with 5d/1d
              missing = [t for t,v in prices.items() if v is None]
              if missing:
                  try:
                      df2 = yf.download(tickers=missing, period="5d", interval="1d",
                                        progress=False, auto_adjust=False, group_by="ticker")
                  except Exception:
                      df2 = None
                  for t in missing:
                      try:
                          sub = df2 if "Close" in df2.columns else df2.get(t)
                          if sub is not None and not sub.empty:
                              c = sub["Close"] if "Close" in sub else sub["Close"]
                              if c is not None and not c.empty:
                                  prices[t] = float(round(c.dropna().iloc[-1], 2))
                      except Exception:
                          pass

              # 3) RSI from 6mo/d1
              try:
                  df3 = yf.download(tickers=tickers, period="6mo", interval="1d",
                                    progress=False, auto_adjust=False, group_by="ticker")
              except Exception:
                  df3 = None
              for t in tickers:
                  try:
                      sub = df3 if "Close" in df3.columns else df3.get(t)
                      if sub is not None and not sub.empty and len(sub) >= 20:
                          close = sub["Close"] if "Close" in sub else sub["Close"]
                          rsi[t] = rsi_wilder(close)
                  except Exception:
                      pass

              return prices, rsi

          def build_sst(prices, rsi_map, sst_inputs):
              out = {}
              for tk, vals in sst_inputs.items():
                  si_sh = vals.get("si_shares")
                  flt   = vals.get("float_shares")
                  avgv  = vals.get("avg_vol_30d")
                  entry = vals.get("entry"); stop = vals.get("stop")
                  t1 = vals.get("t1"); t2 = vals.get("t2")
                  def pct(x,y):
                      try: return round(100*x/y,2) if x is not None and y else None
                      except: return None
                  def div(x,y):
                      try: return round(x/y,2) if x is not None and y else None
                      except: return None
                  out[tk] = {
                      "rsi": rsi_map.get(tk, "data not available") if rsi_map.get(tk) is not None else "data not available",
                      "si_percent_float": pct(si_sh, flt) if pct(si_sh, flt) is not None else "data not available",
                      "days_to_cover": div(si_sh, avgv) if div(si_sh, avgv) is not None else "data not available",
                      "entry": entry if entry is not None else "data not available",
                      "stop":  stop  if stop  is not None else "data not available",
                      "t1":    t1    if t1    is not None else "data not available",
                      "t2":    t2    if t2    is not None else "data not available",
                      "last":  prices.get(tk, "data not available"),
                      "sources": ["sst_inputs.json"]
                  }
              return out

          def _to_num(x):
              try: return float(x)
              except: return None

          def squeeze_score(item):
              rsi = _to_num(item.get("rsi"))
              si  = _to_num(item.get("si_percent_float"))
              dtc = _to_num(item.get("days_to_cover"))
              si_norm  = min(max((si or 0.0), 0.0), 40.0)/40.0
              dtc_norm = min(max((dtc or 0.0), 0.0), 10.0)/10.0
              rsi_norm = 0.0 if rsi is None else max(0.0, 70.0 - rsi)/70.0
              return round((0.5*si_norm + 0.3*dtc_norm + 0.2*rsi_norm)*100, 1)

          def top5_from_sst(sst):
              rows = []
              for tk,v in sst.items():
                  rows.append({
                      "ticker": tk,
                      "score": squeeze_score(v),
                      "rsi": v.get("rsi"),
                      "si_percent_float": v.get("si_percent_float"),
                      "days_to_cover": v.get("days_to_cover"),
                      "entry": v.get("entry"),
                      "stop": v.get("stop"),
                      "targets": [v.get("t1"), v.get("t2")],
                      "sources": v.get("sources", [])
                  })
              rows.sort(key=lambda x: x["score"], reverse=True)
              return rows[:5]

          def build_market_bullets():
              out = {}
              bullets = []
              for tk,label in [("SPY","SPY"),("QQQ","QQQ"),("^VIX","VIX")]:
                  try:
                      d1 = yf.download(tk, period="1d", interval="1m", progress=False, auto_adjust=False)
                      if d1 is not None and not d1.empty:
                          last = round(float(d1["Close"].dropna().iloc[-1]),2)
                          base = float(d1["Close"].dropna().iloc[0])
                          pct = round(100*(last/base-1),2) if base else None
                          out[tk] = {"last": last, "pct_change": pct}
                          if pct is not None:
                              bullets.append(f"{label} {pct}% today")
                      else:
                          out[tk] = {"last":"data not available","pct_change":"data not available"}
                  except Exception:
                      out[tk] = {"last":"data not available","pct_change":"data not available"}
              return {"ticks": out, "bullets": bullets, "sources": ["yfinance"]}

          def ensure_defaults():
              if not os.path.exists(LIVE_PATH):
                  safe_write_json(LIVE_PATH, {"Prices": {}, "RSI": {}, "SST": {}, "SST_TOP5": [], "Market": {}, "last_update_utc": ""})
              if not os.path.exists(SST_PATH):
                  safe_write_json(SST_PATH, {
                      "PLUG": {"si_shares": 100000000, "float_shares": 600000000, "avg_vol_30d": 25000000, "entry": 3.10, "stop": 2.72, "t1": 3.45, "t2": 3.90},
                      "RIOT": {"si_shares": 36000000,  "float_shares": 260000000, "avg_vol_30d": 21000000, "entry": 8.60, "stop": 7.80, "t1": 9.40, "t2": 10.20}
                  })

          def main():
              ensure_defaults()
              tickers = [t.strip().upper() for t in os.getenv("TICKERS","").split(",") if t.strip()]
              data = safe_load_json(LIVE_PATH, {"Prices": {}, "RSI": {}, "SST": {}, "SST_TOP5": [], "Market": {}, "last_update_utc": ""})

              prices, rsi = fetch_prices_and_rsi(tickers)
              # merge
              data["Prices"] = {t: (v if v is not None else "data not available") for t,v in prices.items()}
              data["RSI"]    = {t: rsi.get(t, "data not available") for t in tickers}

              # SST
              sst_inputs = safe_load_json(SST_PATH, {})
              sst = build_sst(prices, rsi, sst_inputs)
              data["SST"] = sst
              data["SST_TOP5"] = top5_from_sst(sst)

              # Market bullets
              data["Market"] = build_market_bullets()

              data["last_update_utc"] = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
              safe_write_json(LIVE_PATH, data)

          if __name__ == "__main__":
              main()
          PY

      - name: Run updater
        run: python scripts/update_live.py

      - name: Commit, rebase, and push
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "auto: populate Prices+RSI for holdings; robust fetch" || echo "No changes to commit"
          git pull --rebase --autostash origin main
          git push origin HEAD:main
